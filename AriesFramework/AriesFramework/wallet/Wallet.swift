// swiftlint:disable inclusive_language

import Foundation
import Indy
import os

public struct DidInfo {
    let did: String
    let verkey: String

    public func getPair() -> (String, String) {
        return (did, verkey)
    }
}

public class Wallet {
    let agent: Agent
    let logger = Logger(subsystem: "AriesFramework", category: "Wallet")
    private var indyWallet: IndyHandle?
    var walletCredentials: String?

    /// Master secret id to identify the prover in AnonCreds. This will not be nil after the agent initialization.
    public private(set) var masterSecretId: String?
    /// Public did generated by the ``AgentConfig.publicDidSeed``.
    public private(set) var publicDid: DidInfo?

    let walletExistKey: String
    let secretIdKey: String

    init(agent: Agent) {
        self.agent = agent

        walletExistKey = agent.agentConfig.label + " aries_framework_wallet_exist"
        secretIdKey = agent.agentConfig.label + " aries_framework_wallet_secret_id_key"
    }

    public var handle: IndyHandle? {
        return indyWallet
    }

    func initialize() async throws {
        logger.info("Initializing wallet for \(self.agent.agentConfig.label)")
        if indyWallet != nil {
          logger.warning("Wallet already initialized.")
          try await close()
        }

        let walletConfig = ["id": agent.agentConfig.walletId].toString()
        let wallet = IndyWallet.sharedInstance()!

        let userDefaults = UserDefaults.standard
        if !userDefaults.bool(forKey: walletExistKey) {
            do {
                walletCredentials = ["key": agent.agentConfig.walletKey, "key_derivation_method": "RAW"].toString()
                try await wallet.createWallet(withConfig: walletConfig, credentials: walletCredentials)
                userDefaults.set(true, forKey: walletExistKey)
            } catch {
                if let err = error as NSError? {
                    logger.error("Cannot create wallet: \(err.userInfo["message"] as? String ?? "Unknown error")")
                }
                throw AriesFrameworkError.frameworkError("Wallet creation failed")
            }
        } else {
            walletCredentials = ["key": agent.agentConfig.walletKey, "key_derivation_method": "RAW"].toString()
        }

        do {
            indyWallet = try await wallet.open(withConfig: walletConfig, credentials: walletCredentials)
        } catch {
            if let err = error as NSError? {
                logger.error("Cannot open wallet: \(err.userInfo["message"] as? String ?? "Unknown error")")
            }
            throw AriesFrameworkError.frameworkError("Wallet opening failed")
        }

        masterSecretId = userDefaults.string(forKey: secretIdKey)
        if masterSecretId == nil {
            masterSecretId = try await IndyAnoncreds.proverCreateMasterSecret(nil, walletHandle: indyWallet!)
            userDefaults.set(masterSecretId, forKey: secretIdKey)
        }
    }

    func close() async throws {
        logger.debug("Closing wallet")
        let wallet = IndyWallet.sharedInstance()!
        try await wallet.close(withHandle: indyWallet!)

        indyWallet = nil
        masterSecretId = nil
        walletCredentials = nil
    }

    func delete() async throws {
        let userDefaults = UserDefaults.standard
        let wallet = IndyWallet.sharedInstance()!
        if indyWallet != nil {
            try? await close()
        }
        if !userDefaults.bool(forKey: walletExistKey) {
            logger.info("Nothing to delete: walley does not exist")
            return
        }
        walletCredentials = ["key": agent.agentConfig.walletKey, "key_derivation_method": "RAW"].toString()
        try await wallet.delete(withConfig: ["id": agent.agentConfig.walletId].toString(), credentials: walletCredentials!)
        walletCredentials = nil

        userDefaults.removeObject(forKey: walletExistKey)
        userDefaults.removeObject(forKey: secretIdKey)
    }

    public func initPublicDid(seed: String) async throws {
        let (did, verkey) = try await createDid(seed: seed)
        publicDid = DidInfo(did: did, verkey: verkey)
    }

    public func createDid(seed: String? = nil) async throws -> (String, String) {
        var config = "{}"
        if let seed = seed {
            config = ["seed": seed].toString()
        }
        let (did, verkey) = try await IndyDid.createAndStoreMyDid(config, walletHandle: indyWallet!)
        return (did!, verkey!)
    }

    public func pack(message: AgentMessage, recipientKeys: [String], senderKey: String?) async throws -> EncryptedMessage {
        let encoder = JSONEncoder()
        let data = try encoder.encode(message)
        let receivers = try JSONSerialization.data(withJSONObject: recipientKeys, options: [])
        let packedMessage = try await IndyCrypto.packMessage(data, receivers: String(data: receivers, encoding: .utf8)!, sender: senderKey, walletHandle: indyWallet!)!

        let decoder = JSONDecoder()
        let encryptedMessage = try decoder.decode(EncryptedMessage.self, from: packedMessage)
        return encryptedMessage
    }

    public func unpack(encryptedMessage: EncryptedMessage) async throws -> DecryptedMessageContext {
        do {
            let encoder = JSONEncoder()
            let encrypted = try encoder.encode(encryptedMessage)
            let decrypted = try await IndyCrypto.unpackMessage(encrypted, walletHandle: indyWallet!)

            let decoder = JSONDecoder()
            let decryptedMessage = try decoder.decode(DecryptedMessageContext.self, from: decrypted ?? Data())
            return decryptedMessage
        } catch {
            if let err = error as NSError? {
                logger.error("Cannot unpack message: \(err.userInfo["message"] as? String ?? "Unknown error")")
            }
            throw AriesFrameworkError.frameworkError("Cannot unpack message")
        }
    }
}
