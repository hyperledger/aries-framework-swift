// swiftlint:disable inclusive_language

import Foundation
import Indy
import os

public struct DidInfo {
    let did: String
    let verkey: String

    public func getPair() -> (String, String) {
        return (did, verkey)
    }
}

public class Wallet {
    let agent: Agent
    let logger = Logger(subsystem: "AriesFramework", category: "Wallet")
    private var indyWallet: IndyHandle?
    var walletCredentials: String?

    /// Public did generated by the ``AgentConfig.publicDidSeed``.
    public private(set) var publicDid: DidInfo?

    init(agent: Agent) {
        self.agent = agent
    }

    public var handle: IndyHandle? {
        return indyWallet
    }

    func initialize() async throws {
        logger.info("Initializing wallet for \(self.agent.agentConfig.label)")
        if indyWallet != nil {
          logger.warning("Wallet already initialized.")
          try await close()
        }

        walletCredentials = ["key": agent.agentConfig.walletKey, "key_derivation_method": "RAW"].toString()
        let walletConfig = ["id": agent.agentConfig.walletId].toString()
        let walletNeedsCreation = !walletExists()
        let wallet = IndyWallet.sharedInstance()!
        
        if walletNeedsCreation {
            do {
                try await wallet.createWallet(withConfig: walletConfig, credentials: walletCredentials)
            } catch {
                if let err = error as NSError? {
                    logger.error("Cannot create wallet: \(err.userInfo["message"] as? String ?? "Unknown error")")
                }
                throw AriesFrameworkError.frameworkError("Wallet creation failed")
            }
        }

        do {
            indyWallet = try await wallet.open(withConfig: walletConfig, credentials: walletCredentials)
            if walletNeedsCreation {
                try await IndyAnoncreds.proverCreateMasterSecret(agent.agentConfig.masterSecretId, walletHandle: indyWallet!)
            }
        } catch {
            if let err = error as NSError? {
                logger.error("Cannot open wallet: \(err.userInfo["message"] as? String ?? "Unknown error")")
            }
            throw AriesFrameworkError.frameworkError("Wallet opening failed")
        }
    }

    func walletExists() -> Bool {
        let f = FileManager.default
        var url = f.urls(for:.documentDirectory, in:.userDomainMask)[0]
        url.appendPathComponent(".indy_client/wallet/\(agent.agentConfig.walletId)")
        return f.fileExists(atPath: url.path)
    }

    func close() async throws {
        logger.debug("Closing wallet")
        let wallet = IndyWallet.sharedInstance()!
        try await wallet.close(withHandle: indyWallet!)

        indyWallet = nil
        walletCredentials = nil
    }

    func delete() async throws {
        let wallet = IndyWallet.sharedInstance()!
        if indyWallet != nil {
            try? await close()
        }

        walletCredentials = ["key": agent.agentConfig.walletKey, "key_derivation_method": "RAW"].toString()
        do {
            try await wallet.delete(withConfig: ["id": agent.agentConfig.walletId].toString(), credentials: walletCredentials!)
        } catch {
            let documentDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
            let walletPath = documentDirectory.appendingPathComponent(".indy_client/wallet")
                                              .appendingPathComponent(agent.agentConfig.walletId)
                                              .appendingPathComponent("sqlite.db")
            try? FileManager.default.removeItem(at: walletPath)
        }
        walletCredentials = nil
    }

    public func initPublicDid(seed: String) async throws {
        let (did, verkey) = try await createDid(seed: seed)
        publicDid = DidInfo(did: did, verkey: verkey)
    }

    public func createDid(seed: String? = nil) async throws -> (String, String) {
        var config = "{}"
        if let seed = seed {
            config = ["seed": seed].toString()
        }
        let (did, verkey) = try await IndyDid.createAndStoreMyDid(config, walletHandle: indyWallet!)
        return (did!, verkey!)
    }

    public func pack(message: AgentMessage, recipientKeys: [String], senderKey: String?) async throws -> EncryptedMessage {
        let encoder = JSONEncoder()
        let data = try encoder.encode(message)
        let receivers = try JSONSerialization.data(withJSONObject: recipientKeys, options: [])
        let packedMessage = try await IndyCrypto.packMessage(data, receivers: String(data: receivers, encoding: .utf8)!, sender: senderKey, walletHandle: indyWallet!)!

        let decoder = JSONDecoder()
        let encryptedMessage = try decoder.decode(EncryptedMessage.self, from: packedMessage)
        return encryptedMessage
    }

    public func unpack(encryptedMessage: EncryptedMessage) async throws -> DecryptedMessageContext {
        do {
            let encoder = JSONEncoder()
            let encrypted = try encoder.encode(encryptedMessage)
            let decrypted = try await IndyCrypto.unpackMessage(encrypted, walletHandle: indyWallet!)

            let decoder = JSONDecoder()
            let decryptedMessage = try decoder.decode(DecryptedMessageContext.self, from: decrypted ?? Data())
            return decryptedMessage
        } catch {
            if let err = error as NSError? {
                logger.error("Cannot unpack message: \(err.userInfo["message"] as? String ?? "Unknown error")")
            }
            throw AriesFrameworkError.frameworkError("Cannot unpack message")
        }
    }
}
